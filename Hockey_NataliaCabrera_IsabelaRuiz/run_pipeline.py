# -*- coding: utf-8 -*-
"""run_pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z6ts0ZiE-45fVOFIkYP80s3MmHSPABL6
"""

!pip install ultralytics filterpy opencv-python torch torchvision

import os
import sys
import cv2
import torch
import numpy as np
import torchvision.transforms as T
from torchvision import models
from ultralytics import YOLO
from google.colab import files

# Agrega sort.py al path
sys.path.append('/content/src')
from sort import Sort

# Modelos y paths
yolo = YOLO("/content/models/best.pt")
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

helmet_model = models.resnet18(pretrained=False, num_classes=2)
helmet_model.load_state_dict(torch.load("/content/models/modelo_casco.pth", map_location=device))
helmet_model.eval().to(device)

glove_model = models.resnet18(pretrained=False, num_classes=2)
glove_model.load_state_dict(torch.load("/content/models/modelo_guantes.pth", map_location=device))
glove_model.eval().to(device)

transform = T.Compose([
    T.ToPILImage(),
    T.Resize((224, 224)),
    T.ToTensor()
])

tracker = Sort()

# Paths
video_path = "/content/data/test.mp4"
output_path = "/content/output/final_demo.mp4"
os.makedirs("/content/output", exist_ok=True)

cap = cv2.VideoCapture(video_path)
w, h = int(cap.get(3)), int(cap.get(4))
out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'mp4v'), 30, (w, h))

# Estado global
no_helmet_ids = set()
no_glove_ids = set()
ids_detectados = set()

frame_idx = 0

print("\n🔍 INICIO DEL PROCESAMIENTO DE VIDEO")
print("---------------------------------------")

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break
    frame_idx += 1

    results = yolo.predict(frame, conf=0.25, imgsz=640)[0]
    boxes = results.boxes
    detections = []

    print(f"\n🟦 Frame {frame_idx}:")
    print(f"🎯 Detecciones: {len(boxes)}")

    if boxes is not None and len(boxes) > 0:
        for box in boxes:
            x1, y1, x2, y2 = map(int, box.xyxy[0].tolist())
            conf = float(box.conf[0])
            cls = int(box.cls[0])
            # ⚠️ Usar la clase real detectada por el modelo
            print(f" - Clase detectada: {cls} | Confianza: {conf:.2f}")
            detections.append([x1, y1, x2, y2, conf])

    if len(detections) == 0:
        out.write(frame)
        continue

    tracks = tracker.update(np.array(detections))

    for d in tracks:
        x1, y1, x2, y2, track_id = map(int, d)
        ids_detectados.add(track_id)

        player_crop = frame[y1:y2, x1:x2]
        if player_crop.size == 0:
            continue

        img_tensor = transform(player_crop).unsqueeze(0).to(device)

        with torch.no_grad():
            casco = helmet_model(img_tensor).argmax(1).item() == 0
            guantes = glove_model(img_tensor).argmax(1).item() == 0

        if not casco:
            no_helmet_ids.add(track_id)
        if not guantes:
            no_glove_ids.add(track_id)

        # Imprimir info por jugador
        print(f"   🧍 ID {track_id} → Casco: {'✔' if casco else '❌'} | Guantes: {'✔' if guantes else '❌'}")

        # Dibujar en el frame
        color = (0, 255, 0) if casco and guantes else (0, 0, 255)
        label = f"ID {track_id} | {'casco✔' if casco else '🚫'} | {'guantes✔' if guantes else '🚫'}"
        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
        cv2.putText(frame, label, (x1, y1 - 10), 0, 0.5, color, 2)

    out.write(frame)

cap.release()
out.release()

# 🔚 RESUMEN FINAL
print("\n======================================")
print("📊 RESUMEN GENERAL DEL VIDEO")
print("======================================")
print(f"🔢 Jugadores detectados (IDs): {sorted(ids_detectados)}")

if not no_helmet_ids and not no_glove_ids:
    print("✅ Todos los jugadores están correctamente equipados.")
else:
    if no_helmet_ids:
        print(f"🚨 Jugadores sin casco: {sorted(no_helmet_ids)}")
    if no_glove_ids:
        print(f"🚨 Jugadores sin guantes: {sorted(no_glove_ids)}")

# 📥 Descargar automáticamente
print("\n📥 Descargando video procesado...")
files.download(output_path)

