# -*- coding: utf-8 -*-
"""run_pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fc2-D1BvWlsByyfuZaHFJX2uU7cVjh-W

**Nombres:** Valentina Hernández Quintana y Laura Alejandra Rincón Castaño.

# **Proyecto final: Identificación automatizada de rampas urbanas para movilidad inclusiva.**

"""**Importamos librerías:**"""

import os
import cv2
import requests
import numpy as np
import pandas as pd
from glob import glob
from github import Github
from ultralytics import YOLO
from roboflow import Roboflow
import matplotlib.pyplot as plt
from IPython.display import display, HTML

"""**Configurar Roboflow y descargar datasets:**"""

rf = Roboflow(api_key="Ouks0aNv3B8r7IcgQDRI")

# Detección
project_det = rf.workspace("vision-computacional-u02en").project("ramps-detection-n1ecd")
version_det = project_det.version(1)
dataset_det = version_det.download("yolov11")

# Segmentación
project_seg = rf.workspace("vision-computacional-u02en").project("ramps-segmentation")
version_seg = project_seg.version(1)
dataset_seg = version_seg.download("yolov11")

"""**Entrenamiento de modelos:**"""

# Cargar el modelo preentrenado para detección
detection_model = YOLO('yolo11n.pt')

# Entrenar el modelo con el dataset propio
detection_model.train(
    data='/content/Ramps-detection-1/data.yaml',
    epochs=150,
    imgsz=640,
    batch=16,
    name='rampa_detection_model',
    augment=True,
    patience=20
)

detection_results = detection_model.predict('/content/Ramps-detection-1/test/images/*', imgsz=640, save=True, conf=0.5)

# Cargar modelo preentrenado para segmentación
segmentation_model = YOLO('yolo11n-seg.pt')

# Entrenar el modelo con nuestro dataset propio
segmentation_model.train(
    data='/content/Ramps-segmentation-1/data.yaml',
    epochs=50,
    imgsz=640,
    batch=16,
    name='rampa_segmentation_model'
)

segmentation_results = segmentation_model.predict('/content/Ramps-segmentation-1/test/images/*', imgsz=640, save=True, conf=0.5)

"""**Obtener coordenadas de la detección y segmentación de un conjunto test:**"""

# Leer el archivo CSV con las coordenadas de las imágenes
rampas_df = pd.read_csv('/content/drive/MyDrive/Visión por computadora/Proyecto Final/Test/RampsGeoreference.csv')

# Cargar el modelo de detección de rampas
detection_model = YOLO('/content/drive/MyDrive/Visión por computadora/Proyecto Final/Modelos/best_detection.pt')

# Cargar el modelo de segmentación de rampas
segmentation_model = YOLO('/content/drive/MyDrive/Visión por computadora/Proyecto Final/Modelos/best_segmentation.pt')

# Ruta de la carpeta "test"
test_images_folder = '/content/drive/MyDrive/Visión por computadora/Proyecto Final/Test'

# Leer todas las imágenes en la carpeta "test"
image_paths = [os.path.join(test_images_folder, filename) for filename in os.listdir(test_images_folder) if filename.endswith('.png')]

# Función para convertir coordenadas de píxeles a geográficas
def pixel_to_geo(x_pixel, y_pixel, image_width, image_height, image_lat, image_lon):

    # Relación de proporción entre píxeles y geográficas
    lat_offset = (y_pixel - image_height / 2) / image_height * 0.001
    lon_offset = (x_pixel - image_width / 2) / image_width * 0.001

    # Convertir píxeles a coordenadas geográficas
    rampa_lat = image_lat + lat_offset
    rampa_lon = image_lon + lon_offset

    return rampa_lat, rampa_lon

# Crear un nuevo DataFrame para almacenar los resultados con las coordenadas de las rampas
rampas_with_coords_df = pd.DataFrame(columns=['image_id', 'latitude', 'longitude', 'rampa_id', 'rampa_lat', 'rampa_lon'])

# Procesar cada imagen y asignar las coordenadas
for image_path in image_paths:

    # Extraer el nombre de la imagen para usarlo como image_id
    image_filename = os.path.basename(image_path)
    image_id = os.path.splitext(image_filename)[0]

    image = cv2.imread(image_path)
    if image is None:
        print(f"Warning: Could not read image at {image_path}. Skipping.")
        continue

    # Obtener las dimensiones de la imagen
    image_height, image_width, _ = image.shape

    # Obtener las coordenadas geográficas de la imagen desde el CSV
    image_coords_row = rampas_df[rampas_df['image_id'] == image_id]

    if image_coords_row.empty:
        print(f"Warning: No coordinates found for image_id '{image_id}' in the CSV. Skipping.")
        continue

    image_lat = image_coords_row['latitude'].values[0]
    image_lon = image_coords_row['longitude'].values[0]

    print(f"Procesando {image_id} con coordenadas: ({image_lat}, {image_lon})")

    # Realizar la detección de rampas
    results = detection_model.predict(image, conf=0.5)

    # Dibujar las bounding boxes y asignar coordenadas geográficas a cada rampa detectada
    if results and len(results) > 0 and results[0].boxes:
        for box_id, box in enumerate(results[0].boxes.xywh):  # results.xywh contiene las coordenadas de las cajas
            x_center, y_center, width, height = box[:4].tolist()

            # Convertir las coordenadas de píxeles a geográficas
            rampa_lat, rampa_lon = pixel_to_geo(x_center, y_center, image_width, image_height, image_lat, image_lon)

            # Dibujar la caja en la imagen
            x1 = int(x_center - width / 2)
            y1 = int(y_center - height / 2)
            x2 = int(x_center + width / 2)
            y2 = int(y_center + height / 2)

            # Dibujar la caja en la imagen original
            cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)

            # Realizar la segmentación de rampas para obtener la máscara
            segmentation_results = segmentation_model.predict(image, conf=0.3)

            # Comprobamos si hay máscaras presentes antes de iterar
            if segmentation_results and len(segmentation_results) > 0 and segmentation_results[0].masks is not None:

                for seg_mask in segmentation_results[0].masks.data:
                    mask = seg_mask.cpu().numpy()  # Convertir la máscara a formato numpy

                    # Redimensionar la máscara para que tenga las mismas dimensiones que la imagen original
                    mask_resized = cv2.resize(mask, (image_width, image_height), interpolation=cv2.INTER_NEAREST)

                    # Convertir la máscara en blanco y negro (binaria)
                    mask_resized = (mask_resized > 0.5).astype('uint8') * 255

                    # Convertir la máscara a 3 canales para combinarla con la imagen original
                    mask_3_channels = cv2.cvtColor(mask_resized, cv2.COLOR_GRAY2BGR)

                    # Superponer la máscara sobre la imagen
                    image = cv2.addWeighted(image, 1, mask_3_channels, 0.5, 0)
            else:
                print(f"No masks detected for {image_id}.")

            # Añadir el id de la rampa y las coordenadas geográficas a la base de datos
            new_row = {
                'image_id': image_id,
                'latitude': image_lat,
                'longitude': image_lon,
                'rampa_id': box_id + 1,
                'rampa_lat': rampa_lat,
                'rampa_lon': rampa_lon
            }
            rampas_with_coords_df = pd.concat([rampas_with_coords_df, pd.DataFrame([new_row])], ignore_index=True)

    # Mostrar la imagen con las cajas de las rampas y la segmentación
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    plt.imshow(image_rgb)
    plt.title(f"Imagen con Rampas Detectadas: {image_id}")
    plt.axis('off')
    plt.show()

# Guardar el archivo CSV actualizado
rampas_with_coords_df.to_csv('rampas_con_coordenadas.csv', index=False)

print("Archivo CSV actualizado con las coordenadas de las rampas.")

"""**Visualización de las rampas en un mapa interactivo:**"""

# Autenticación con GitHub
token = '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'
g = Github(token)

# Acceder al repositorio de GitHub
repo = g.get_user().get_repo('Mapa-rampas')

# Subimos el archivo CSV
file_path = '/content/rampas_con_coordenadas.csv'

# Leer el contenido del archivo CSV
with open(file_path, 'r') as file:
    content = file.read()

# Comprobar si el archivo ya existe en el repositorio
try:

    # Intentar obtener el archivo existente
    existing_file = repo.get_contents("rampas_con_coordenadas.csv")
    sha = existing_file.sha  # Obtener el SHA del archivo existente

    # Actualizar el archivo con el contenido nuevo
    repo.update_file(existing_file.path, "Actualización del archivo CSV", content, sha, branch="main")
    print("Archivo CSV actualizado exitosamente en GitHub.")

except Exception as e:

    # Si el archivo no existe, crearlo
    repo.create_file("rampas_con_coordenadas.csv", "Creación del archivo CSV", content, branch="main")
    print("Archivo CSV creado exitosamente en GitHub.")

# Verificamos que si se hubiera realizado la actualización del CSV en GitHub
repo = g.get_user().get_repo('mapa-rampas')
file_content = repo.get_contents('rampas_con_coordenadas.csv')

print(f"Última actualización del archivo CSV: {file_content.last_modified}")

# Abrimos el HTML
github_page_url = 'https://laurar287.github.io/Mapa-rampas/'
display(HTML(f'<a href="{github_page_url}" target="_blank">Abrir GitHub Page</a>'))
